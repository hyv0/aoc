import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.ListIterator;
import java.util.PriorityQueue;
import java.util.TreeSet;

import aoclib.BaseSolution;
import aoclib.Caster;
import aoclib.Parser;
import aoclib.Parser.DefaultSink;

public class Day21 extends BaseSolution {
	
	

	public Day21() {
		super(21);
	}
	
	private final int[][] NUMERIC_KEYPAD = new int[][] {{7,8,9},{4,5,6},{1,2,3},{-1,0,10}};
	private final int[][] DIRECTIONAL_KEYPAD = new int[][] {{-1,3,10},{2,1,0}};
	private final int[][] DIRS = new int[][] {{0,1},{1,0},{0,-1},{-1,0}}; 
	
	@Override
	protected void solveDay() {
		long p1 = 0;
		long p2 = 0;
		
		int[][] input = new int[5][4];
		int index = 0;
		for(String line : super.inputfileLines) {
			DefaultSink sink = (DefaultSink) Parser.extractNumbers(line,false,1,null);
			long[] numbers = Caster.castLong(sink.toArr());
			input[index][0] = (int) numbers[0];
			input[index][1] = (int) numbers[1];
			input[index][2] = (int) numbers[2];
			input[index][3] = 10;
			index++;
		}
		
		for(int i =0; i < input.length; i++) {
			ArrayList<ArrayList<Integer>> patternToTypeOnNumericKeypad = findPatternToType(NUMERIC_KEYPAD, input[i]);
			
			ArrayList<ArrayList<Integer>> patternToTypeIn = patternToTypeOnNumericKeypad;
			ArrayList<ArrayList<Integer>> patternToTypeOut = new ArrayList<ArrayList<Integer>>();
			
			for(int keypads = 0; keypads < 2; keypads++) {
				for(ArrayList<Integer> list : patternToTypeIn) {
					patternToTypeOut.addAll(findPatternToType(DIRECTIONAL_KEYPAD, Caster.toArray(list)));
				}
				patternToTypeIn = patternToTypeOut;
				patternToTypeOut = new ArrayList<ArrayList<Integer>>();
			}
			
			int shortest = Integer.MAX_VALUE;
			ArrayList<Integer> shortestList = null;
			for(ArrayList<Integer> list : patternToTypeIn) {
				if(list.size() < shortest) {
					shortest = list.size();
					shortestList = list;
				}
			}
			/*
			String g = "Part1 shortest list: ";
			for(int gg : shortestList) {
				g += gg + ",";
			}
			System.out.println(g);
			System.out.println(" " + super.inputfileLines[i] +"   " + shortest + "       cpu load " + patternToTypeIn.size()+"\n");
			*/
			p1 += calcLineScore(i,shortest);
			
			// ==================================================================
			// part 2. we have to face the truth. bruteforcing won't work.
			// ==================================================================
			
			
			long shortestP2 = Long.MAX_VALUE;
			for(ArrayList<Integer> list : patternToTypeOnNumericKeypad) {
				long p2S = findPatternToTypeDeepDive(DIRECTIONAL_KEYPAD, list, 25);
				if(p2S < shortestP2) {
					shortestP2 = p2S;
				}
			}
			p2 += calcLineScore(i, shortestP2) ;
		}
		
		part1(p1);
		part2(p2);
		
		
		// Algorithm: calculating layer by layer and avoiding duplicates; Not working for 25. Stops at 11 layers depth...
		/*
		for(int i =0; i < input.length; i++) {
			GraphElement root = new GraphElement(-1);
			GraphElement prev = root;
			for(int n : input[i]) {
				GraphElement newElem = new GraphElement(n);
				prev.addSuccessor(newElem);
				prev = newElem;
			}
			GraphElement out = new GraphElement(-1, 3 , 2);
			findPatternToTypeWithGraph(NUMERIC_KEYPAD, root,out);
			

			System.out.println("input   " + super.inputfileLines[i]);
			long shortest = 0;
			for(int keypads = 0; keypads < 25; keypads++) {
				System.out.println("iteration " + keypads + " shortest = " + shortest + "  cpu load = " + out.getAllNodesCount());
				GraphElement in = out;
				out = new GraphElement(-1,0,2);

				shortest = findPatternToTypeWithGraph(DIRECTIONAL_KEYPAD, in,out);
			}
			
			System.out.println(" " + super.inputfileLines[i] +"   " + shortest+"\n\n\n");
			long complexity = shortest * Caster.castLong(((DefaultSink)Parser.extractNumbers(super.inputfileLines[i], false, -1, null)).toArr())[0];
			p1 += complexity;
			
		}
		*/
		
		
	}

	private long calcLineScore(int lineNr, long shortestPath) {
		return shortestPath * Caster.castLong(((DefaultSink)Parser.extractNumbers(super.inputfileLines[lineNr], false, -1, null)).toArr())[0];
	}

	/***
	 * bfs bruteforce. simulates one robot-layer. Output: all different combinations. Can be used for a few layers. Not for 25. 
	 * @param usedKeypad the used keypad which should be typed on.
	 * @param requiredOutput the output which should be generated by typing on the keypad
	 * @return The sequence of actions used to type on the keypad to produce the requiredOutput
	 */
	private ArrayList<ArrayList<Integer>> findPatternToType(int[][] usedKeypad, int[] requiredOutput) {
		int iArm = -1;
		int jArm = -1;
		for(int i= 0; i < usedKeypad.length; i++) {
			for(int j= 0; j < usedKeypad[0].length; j++) {
				if(usedKeypad[i][j] == 10) {
					iArm = i;
					jArm = j;
				}
			}
		}
		ArrayList<ArrayList<Integer>> ret = new ArrayList<ArrayList<Integer>>();
		for(int input = 0; input < requiredOutput.length; input++) {
			int digit = requiredOutput[input];
			outer:
			for(int i= 0; i < usedKeypad.length; i++) {
				for(int j= 0; j < usedKeypad[0].length; j++) {
					if(usedKeypad[i][j] == digit) {
						// prio to generate: 0|3 , 1 , 2  // update: nope. I don't think there is a global best order. it depends on the following numbers...
						
						
						ArrayList<Integer> pressesA = new ArrayList<Integer>();
						boolean okA = true;
						int ii = iArm;
						int jj = jArm;
						for(; jj != j; jj+= ((j > jArm)?(1):(-1))) {
							pressesA.add((j > jArm)?0:2);
							if(usedKeypad[ii][jj] == -1) {
								okA=false;
							}
						}
						for(; ii != i; ii+= ((i > iArm)?1:-1)) {
							pressesA.add((i > iArm)?1:3);
							if(usedKeypad[ii][jj] == -1) {
								okA = false;
							}
						}
						
						ArrayList<Integer> pressesB = new ArrayList<Integer>();
						boolean okB = true;
						ii = iArm;
						jj = jArm;
						for(; ii != i; ii+= ((i > iArm)?1:-1)) {
							pressesB.add((i > iArm)?1:3);
							if(usedKeypad[ii][jj] == -1) {
								okB = false;
							}
						}
						for(; jj != j; jj+= ((j > jArm)?1:-1)) {
							pressesB.add((j > jArm)?0:2);
							if(usedKeypad[ii][jj] == -1) {
								okB=false;
							}
						}
						pressesA.add(10);
						pressesB.add(10);
						
						if(iArm -i == 0 || jArm-j==0) {
							okB = false;
						}
						

						if(ret.size() == 0) {
							if(okA) {
								ret.add(pressesA);
							}
							if(okB) {
								ret.add(pressesB);
							}
						
						}else {
							if(okA && okB) {
								ArrayList<ArrayList<Integer>> copy = new ArrayList<ArrayList<Integer>>();
								for(ArrayList<Integer> list : ret) {
									ArrayList<Integer> copyList = new ArrayList<Integer>();
									copyList.addAll(list);
									copy.add(copyList);
								}
								for(ArrayList<Integer> list : ret) {
									list.addAll(pressesA);
								}
								for(ArrayList<Integer> list : copy) {
									list.addAll(pressesB);
								}
								ret.addAll(copy);
							}else {
								if(okA) {
									for(ArrayList<Integer> list : ret) {
										list.addAll(pressesA);
									}
								}
								if(okB) {
									for(ArrayList<Integer> list : ret) {
										list.addAll(pressesB);
									}
								}
							}
						}
						iArm = i;
						jArm = j;
						
						break outer;
					}
				}
			}
		}
		return ret;
	}
	

	// ============================
	// P A R T 2.   Try 1:    BFS. not working for depth=25. kept for legacy purposes (So much effort was spent for programming this).
	//                        See DFS (try 2)for the used solution
	// ===========================
	
	/**
	 * Same as {@link #findPatternToType(int[][] usedKeypad, int[] requiredOutput) findPatternToType}, but does not duplicate the return array if there is a second option.
	 * It uses a Graph for storing alternating paths and thus avoiding calculating duplicate stuff.
	 * @param usedKeypad
	 * @param input
	 * @param outputRoot the generated output is added here.
	 * @return
	 */
	@SuppressWarnings("unused")
	private long findPatternToTypeWithGraph(int[][] usedKeypad, GraphElement input, GraphElement outputRoot) {

		
		long shortest = Long.MAX_VALUE;
		
		
		PriorityQueue<IterativeRecursion> trunk = new PriorityQueue<IterativeRecursion>(new Comparator<IterativeRecursion>() {

			@Override
			public int compare(Day21.IterativeRecursion o1, Day21.IterativeRecursion o2) {
				return (int) (o1.pathLength - o2.pathLength);
			}
		});
		trunk.add(new IterativeRecursion(outputRoot,input,0));
		
		while(!trunk.isEmpty()) {
			IterativeRecursion recursionStep = trunk.poll();

			
			
			int iArm = recursionStep.addHere.tmpI;
			int jArm = recursionStep.addHere.tmpJ;
			
			
			for(GraphElement elem : recursionStep.input.successors) {
				int digit = elem.actionCode;
				GraphElement reuseElement = elem.tmpProcessed;
				
				outer:
				for(int i= 0; i < usedKeypad.length; i++) {
					for(int j= 0; j < usedKeypad[0].length; j++) {
						if(usedKeypad[i][j] == digit) {
							
							ArrayList<Integer> pressesA = new ArrayList<Integer>();
							boolean okA = true;
							int ii = iArm;
							int jj = jArm;
							for(; jj != j; jj+= ((j > jArm)?(1):(-1))) {
								pressesA.add((j > jArm)?0:2);
								if(usedKeypad[ii][jj] == -1) {
									okA=false;
								}
							}
							for(; ii != i; ii+= ((i > iArm)?1:-1)) {
								pressesA.add((i > iArm)?1:3);
								if(usedKeypad[ii][jj] == -1) {
									okA = false;
								}
							}
							
							ArrayList<Integer> pressesB = new ArrayList<Integer>();
							boolean okB = true;
							ii = iArm;
							jj = jArm;
							for(; ii != i; ii+= ((i > iArm)?1:-1)) {
								pressesB.add((i > iArm)?1:3);
								if(usedKeypad[ii][jj] == -1) {
									okB = false;
								}
							}
							for(; jj != j; jj+= ((j > jArm)?1:-1)) {
								pressesB.add((j > jArm)?0:2);
								if(usedKeypad[ii][jj] == -1) {
									okB=false;
								}
							}
							
							if(iArm -i == 0 || jArm-j==0) {
								okB = false; // they are the same. just use option a
							}
							
							GraphElement actionPress = new GraphElement(10, i, j);
							
							if(reuseElement != null) {
								if(actionPress.tmpI != reuseElement.tmpI || actionPress.tmpJ != reuseElement.tmpJ) {
									throw new RuntimeException("error");
								}
								actionPress = reuseElement;
							}
							
							
							if(okA) {
								GraphElement prev = recursionStep.addHere;
								for(Integer press : pressesA) {
									GraphElement p = new GraphElement(press);
									prev.addSuccessor(p);
									prev = p;
								}
								prev.addSuccessor(actionPress);
							}
							if(okB) {
								GraphElement prev = recursionStep.addHere;
								for(Integer press : pressesB) {
									GraphElement p = new GraphElement(press);
									prev.addSuccessor(p);
									prev = p;
								}
								prev.addSuccessor(actionPress);
							}
							long length =  pressesA.size() + 1 + recursionStep.pathLength; //+1 for actionPress
							if(elem.successors.size() == 0) {
								if(length < shortest) {
									shortest = length;
								}
							}else {
								if(reuseElement == null) {
									elem.tmpProcessed = actionPress;
									trunk.add(new IterativeRecursion(actionPress, elem, length));
									 
								}else {
									//System.out.println("!!! CYCLE DETECTED AND NODE REUSED");
								}
							}
							break outer;
						}
					}
				}
			}
			
		}
		
		return shortest;
	}
		
	private static class IterativeRecursion{
		GraphElement addHere;
		GraphElement input;
		long pathLength;
		public IterativeRecursion(GraphElement addHere, GraphElement input, long pathLength) {
			this.addHere = addHere;
			this.input = input;
			this.pathLength = pathLength;
		}
	}
	
	private static class GraphElement{
		int actionCode;
		ArrayList<GraphElement> successors;
		int tmpI = 0;
		int tmpJ = 0;
		GraphElement tmpProcessed = null;
		
		
		public GraphElement(int actionCode, int i, int j ) {
			this.actionCode = actionCode;
			tmpI = i;
			tmpJ = j;
			successors = new ArrayList<Day21.GraphElement>();
		}
		public GraphElement(int actionCode ) {
			this.actionCode = actionCode;
			successors = new ArrayList<Day21.GraphElement>();
		}
		public void addSuccessor(GraphElement element ) {
			this.successors.add(element);
		}
		
		public void print2(String r) {
			//String t = r + "," + actionCode + "(" + this.toString().substring(18) + ") ";
			String t = r + "," + actionCode;
			if(successors.size() > 0) {
				for(GraphElement g : successors) {
					g.print2(t);
				}
			}else {
				System.out.println(t);
			}
		}
		
		public long getAllNodesCount() {
			HashSet<GraphElement> e = new HashSet<Day21.GraphElement>();
			
			ArrayList<GraphElement> trunk = new ArrayList<Day21.GraphElement>();
			trunk.add(this);
			
			while(!trunk.isEmpty()) {
				GraphElement r = trunk.removeFirst();
				if(e.contains(r)) {
					continue;
				}
				e.add(r);
				trunk.addAll(r.successors);
			}
			
			
			return e.size();
			
		}
		
		public void print(String r, HashSet<GraphElement> printed) {
			//print2(r);
			//if(true) return;

			if(printed.contains(this)) {
				System.out.println(r );
				return;
			}
			r = r + "," + actionCode;
			String blanks = "";
			for(int i = 0; i < r.length(); i++) {
				blanks += " ";
			}

			boolean first = true;
			printed.add(this);
			if(successors.size() > 0) {
				for(GraphElement g : successors) {
					if(first) {
						g.print(r,printed);
						first = false;
					}else {
						g.print(blanks, printed);
					}
				}
			}else {
				System.out.println(r + "," + actionCode);
			}
		}
	}
	
	
	
	
	
	
	
	// ============================================================================
	//
	//                                   D F S
	//
	// Because this breath first is not working, depth first with a cache is used. 
	// Don't store the actual pattern. We are not interested in it.
	// Only shortest pattern-count matters.
	// The cache stores the shortest pattern-count to type to avoid recalculating the same stuff again and again.
	//
	// ============================================================================
	
	//gigantic function-CACHE: depth and requiredOutput-Array -> MinimalPathLength
	private  long[][][][][] cache = new long[26][6][6][6][6];
	

	private long findPatternToTypeDeepDive(int[][] usedKeypad, ArrayList<Integer> requiredOutput, int requiredDepth) {
		if(requiredDepth == 0) {
			return requiredOutput.size();
		}
		if(requiredOutput.size() <= 4) {
			long cachedValue = cache[requiredDepth][calcCacheIndex(0,requiredOutput)][calcCacheIndex(1, requiredOutput)][calcCacheIndex(2, requiredOutput)][calcCacheIndex(3, requiredOutput)];

			if(cachedValue != 0) {
				return cachedValue;
			}
		}else {
			// for typing onto the numeric keypad, the requiredOutput-array can be longer. Because it's only the first layer, there is no caching necessary
		}
		
		
		int iArm = -1;
		int jArm = -1;
		for(int i= 0; i < usedKeypad.length; i++) {
			for(int j= 0; j < usedKeypad[0].length; j++) {
				if(usedKeypad[i][j] == 10) {
					iArm = i;
					jArm = j;
				}
			}
		}
		long pathLength = 0;
		for(int digit: requiredOutput) {
			outer:
			for(int i= 0; i < usedKeypad.length; i++) {
				for(int j= 0; j < usedKeypad[0].length; j++) {
					if(usedKeypad[i][j] == digit) {
						
						ArrayList<Integer> pressesA = new ArrayList<Integer>();
						boolean okA = true;
						int ii = iArm;
						int jj = jArm;
						for(; jj != j; jj+= ((j > jArm)?(1):(-1))) {
							pressesA.add((j > jArm)?0:2);
							if(usedKeypad[ii][jj] == -1) {
								okA=false;
							}
						}
						for(; ii != i; ii+= ((i > iArm)?1:-1)) {
							pressesA.add((i > iArm)?1:3);
							if(usedKeypad[ii][jj] == -1) {
								okA = false;
							}
						}
						
						ArrayList<Integer> pressesB = new ArrayList<Integer>();
						boolean okB = true;
						ii = iArm;
						jj = jArm;
						for(; ii != i; ii+= ((i > iArm)?1:-1)) {
							pressesB.add((i > iArm)?1:3);
							if(usedKeypad[ii][jj] == -1) {
								okB = false;
							}
						}
						for(; jj != j; jj+= ((j > jArm)?1:-1)) {
							pressesB.add((j > jArm)?0:2);
							if(usedKeypad[ii][jj] == -1) {
								okB=false;
							}
						}
						pressesA.add(10);
						pressesB.add(10);
						
						if(iArm -i == 0 || jArm-j==0) {
							okB = false;
						}
						


						long pathLengthSubA = Long.MAX_VALUE;
						long pathLengthSubB = Long.MAX_VALUE;
						if(okA) {
							pathLengthSubA = findPatternToTypeDeepDive(usedKeypad, pressesA, requiredDepth-1);
						}
						if(okB) {
							pathLengthSubB = findPatternToTypeDeepDive(usedKeypad, pressesB, requiredDepth-1);
						}
						pathLength += pathLengthSubA < pathLengthSubB ? pathLengthSubA : pathLengthSubB;
						
						iArm = i;
						jArm = j;
						
						break outer;
					}
				}
			}
		}
		if(requiredOutput.size() <= 4) {
			cache[requiredDepth][calcCacheIndex(0,requiredOutput)][calcCacheIndex(1, requiredOutput)][calcCacheIndex(2, requiredOutput)][calcCacheIndex(3, requiredOutput)] = pathLength;
		}
		return pathLength;
	}
	
	/**
	 * Matches the used numbers in the directional keypad that can occur 0-3 for the direction, "unused" = no further output required, "action-press" to 0-5 to reduce the required size of the dimensions of the multi-dim array
	 * @param index
	 * @param list
	 * @return
	 */
	private int calcCacheIndex(int index,ArrayList<Integer> list) {
		if(list.size() <= index) {
			return 5;
		}
		
		int v =  list.get(index);
		if(v==10) {
			return 4;
		}
		return v;
	}

	
	

}
